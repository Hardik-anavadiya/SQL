Chapter:- SQL Basics: Data Retrieval - Single Table


TOPC 5 :-

### Module: Retrieve data using text query(SELECT, WHERE, DISTINCT, LIKE)

-- Simply print all the movies 
	SELECT * from movies;

-- Get movie title and industry for all the movies
	SELECT title, industry from movies;

-- Print all movies from Hollywood 
	SELECT * from movies where industry="Hollywood";
  
-- Print all moves from Bollywood 
	SELECT * from movies where industry="Bollywood";

-- Get all the unique industries in the movies database
	SELECT DISTINCT industry from movies;

-- Select all movies that starts with THOR
	SELECT * from movies where title LIKE 'THOR%';

-- Select all movies that have 'America' word in it. That means to select all captain America movies
	SELECT * from movies where title LIKE '%America%';

-- How many Hollywood movies are present in the database?
	SELECT COUNT(*) from movies where industry="Hollywood";

-- Print all  movies where we don't know the value of the studio
	SELECT * FROM movies WHERE studio='';




### Module: Retrieve data using numeric query (BETWEEN, IN, ORDER BY, LIMIT, OFFSET)

-- Which movies had greater than 9 imdb rating?
	SELECT * from movies where imdb_rating>9;

-- Movies with rating between 6 and 8
	SELECT * from movies where imdb_rating>=6 and imdb_rating <=8;
	SELECT * from movies where imdb_rating BETWEEN 6 AND 8;

-- Select all movies whose release year can be 2018 or 2019 or 2022
	-- Approach1:
	SELECT * from movies where release_year=2022 
	or release_year=2019 or release_year=2018;

	-- Approach2:
	SELECT * from movies where release_year IN (2018,2019,2022);

-- All movies where imdb rating is not available (imagine the movie is just released)
	SELECT * from movies where imdb_rating IS NULL;

-- All movies where imdb rating is available 
	SELECT * from movies where imdb_rating IS NOT NULL;

-- Print all bollywood movies ordered by their imdb rating
	SELECT * 
        from movies WHERE industry = "bollywood"
        ORDER BY imdb_rating ASC;

-- Print first 5 bollywood movies with highest rating
	SELECT * 
        from movies WHERE industry = "bollywood"
        ORDER BY imdb_rating DESC LIMIT 5;

-- Select movies starting from second highest rating movie till next 5 movies for bollywood
	SELECT * 
        from movies WHERE industry = "bollywood"
        ORDER BY imdb_rating DESC LIMIT 5 OFFSET 1;





### Module: Summary Analytics (COUNT, MAX, MIN, AVG, GROUP BY)
 
-- How many total movies do we have in our movies table?
	SELECT COUNT(*) from movies;
	
-- Select highest imdb rating for bollywood movies
	SELECT MAX(imdb_rating) from movies where industry="Bollywood";

-- Select lowest imdb rating for bollywood movies
	SELECT MIN(imdb_rating) from movies where industry="Bollywood";

-- Print average rating of Marvel Studios movies
	SELECT AVG(imdb_rating) from movies where studio="Marvel Studios";
	SELECT ROUND(AVG(imdb_rating),2) from movies where studio="Marvel Studios";

-- Print min, max, avg rating of Marvel Studios movies
	SELECT 
           MIN(imdb_rating) as min_rating, 
           MAX(imdb_rating) as max_rating, 
           ROUND(AVG(imdb_rating),2) as avg_rating
        FROM movies 
        WHERE studio="Marvel Studios";

-- Print count of movies by industry
	SELECT 
           industry, count(industry) 
        FROM movies
        GROUP BY industry;

-- Same thing but add average rating
	SELECT 
            industry, 
            count(industry) as movie_count,
            avg(imdb_rating) as avg_rating
	FROM movies
	GROUP BY industry;

-- Count number of movies released by a given production studio
	SELECT 
	    studio, count(studio) as movies_count 
        from movies WHERE studio != ''
	GROUP BY studio
	ORDER BY movies_count DESC;

-- What is the average rating of movies per studio and also order them by average rating in descending format?
	SELECT 
	   studio, 
	   count(studio) as cnt, 
	   round(avg(imdb_rating), 1) as avg_rating 
	from movies WHERE studio != ''
	GROUP BY studio
        order by avg_rating DESC;

       



### Module: HAVING Clause

-- Print all the years where more than 2 movies were released
	SELECT 
           release_year, 
           count(*) as movies_count
	FROM movies    
	GROUP BY release_year
	HAVING movies_count>2
	ORDER BY movies_count DESC;




### Module: Calculated Columns (IF, CASE, YEAR, CURYEAR)

-- Print actor name, their birth_year and age
	SELECT 
           name, birth_year, (YEAR(CURDATE())-birth_year) as age
	FROM actors;

-- Print profit for every movie
	SELECT 
	    *, 
           (revenue-budget) as profit 
	from financials;

-- Print revenue of all movies in INR currency
	SELECT 
           movie_id, 
	   revenue, 
           currency, 
           unit,
           IF (currency='USD', revenue*77, revenue) as revenue_inr
	FROM financials;

-- Get all the unique units from financial table
	select 
	   distinct unit 
	From financials;

-- Print revenue in millions 
	SELECT 
           movie_id, revenue, currency, unit,
           CASE
              WHEN unit="Thousands" THEN revenue/1000
              WHEN unit="Billions" THEN revenue*1000
             ELSE revenue
           END as revenue_mln
	FROM financials




TOPIC 6 :-

Chapter:- SQL Basics: Data Retrieval - Multiple Tables


### Module: SQL Joins (INNER, LEFT, RIGHT, FULL)

-- Print all movies along with their title, budget, revenue, currency and unit. [INNER JOIN]
	SELECT 
            m.movie_id, title, budget, revenue, currency, unit 
	FROM movies m
	INNER JOIN financials f
	ON m.movie_id=f.movie_id;

-- Perform LEFT JOIN on above discussed scenario
	SELECT 
            m.movie_id, title, budget, revenue, currency, unit 
	FROM movies m
	LEFT JOIN financials f
	ON m.movie_id=f.movie_id;

-- Perform RIGHT JOIN on above discussed scenario
	SELECT 
            m.movie_id, title, budget, revenue, currency, unit 
	FROM movies m
	RIGHT JOIN financials f
	ON m.movie_id=f.movie_id;

-- Perform FULL JOIN using 'Union' on above two tables [movies, financials]
	SELECT 
            m.movie_id, title, budget, revenue, currency, unit 
	FROM movies m
	LEFT JOIN financials f
	ON m.movie_id=f.movie_id

	UNION

	SELECT 
            m.movie_id, title, budget, revenue, currency, unit 
	FROM movies m
	RIGHT JOIN financials f
	ON m.movie_id=f.movie_id;

-- Interchanging the position of Left and Right Tables
	Select 
	    m.movie_id, title, revenue 
	from movies m 
        left join financials f
        on m.movie_id = f.movie_id;

	Select 
	    m.movie_id, title, revenue 
	from financials f 
        left join movies m
        on m.movie_id = f.movie_id;

-- Replacing 'ON' with 'USING' while joining conditions
	Select 
	   m.movie_id, title, revenue 
	from movies m 
        left join financials f
	USING (movie_id);
      


	
### Module: Cross Join

-- Print a list of final menu items along with their price for a restaurant.
	SELECT 
           *, 
           CONCAT(name, " - ", variant_name) as full_name,
           (price+variant_price) as full_price
	FROM food_db.items
	CROSS JOIN food_db.variants;




### Module: Analytics on Tables

-- Find profit for all movies 
	SELECT 
           m.movie_id, title, budget, revenue, currency, unit, 
	   (revenue-budget) as profit 
	FROM movies m
	JOIN financials f
	ON m.movie_id=f.movie_id;

-- Find profit for all movies in bollywood
	SELECT 
           m.movie_id, title, budget, revenue, currency, unit, 
	   (revenue-budget) as profit 
	FROM movies m
	JOIN financials f
	ON m.movie_id=f.movie_id
	WHERE m.industry="Bollywood";

-- Find profit of all bollywood movies and sort them by profit amount (Make sure the profit be in millions for better comparisons)
	SELECT 
    	    m.movie_id, title revenue, currency, unit, 
            CASE 
                WHEN unit="Thousands" THEN ROUND((revenue-budget)/1000,2)
        	WHEN unit="Billions" THEN ROUND((revenue-budget)*1000,2)
                ELSE revenue-budget
            END as profit_mln
	FROM movies m
	JOIN financials f 
	ON m.movie_id=f.movie_id
	WHERE m.industry="Bollywood"
	ORDER BY profit_mln DESC;





### Module: Join More Than Two Tables

-- Show comma separated actor names for each movie
	SELECT 
            m.title, group_concat(name separator " | ") as actors
	FROM movies m
	JOIN movie_actor ma ON m.movie_id=ma.movie_id
	JOIN actors a ON a.actor_id=ma.actor_id
	GROUP BY m.movie_id;

-- Print actor name and all the movies they are part of
	SELECT 
            a.name, GROUP_CONCAT(m.title SEPARATOR ' | ') as movies
	FROM actors a
	JOIN movie_actor ma ON a.actor_id=ma.actor_id
	JOIN movies m ON ma.movie_id=m.movie_id
	GROUP BY a.actor_id;

-- Print actor name and how many movies they acted in
	SELECT 
            a.name, 
            GROUP_CONCAT(m.title SEPARATOR ' | ') as movies,
            COUNT(m.title) as num_movies
	FROM actors a
	JOIN movie_actor ma ON a.actor_id=ma.actor_id
	JOIN movies m ON ma.movie_id=m.movie_id
	GROUP BY a.actor_id
	ORDER BY num_movies DESC;





TOPIC 7 & 8



Chapter:- SQL Basics: Complex Queries



### Module: Subqueries

-- Select a movie with highest imdb_rating
	-- without subquery
	select * from movies order by imdb_rating desc limit 1;
	
	-- with subquery
	select * from movies where imdb_rating=(select max(imdb_rating) from movies);

-- Select a movie with highest and lowest imdb_rating
	-- without subquery
	select * from movies where imdb_rating in (1.9, 9.3);

	-- with subquery
	select * from movies where imdb_rating in (
        				(select min(imdb_rating) from movies), 
    					(select max(imdb_rating) from movies)
						);

-- Select all the actors whose age is greater than 70 and less than 85
	select 
	    actor_name, age
	FROM 
  	    (Select
                name as actor_name,
                (year(curdate()) - birth_year) as age
    	     From actors
            ) AS actors_age_table
	WHERE age > 70 AND age < 85;


	


### Module: ANY, ALL Operators

-- select actors who acted in any of these movies (101,110, 121)
	select * From actors WHERE actor_id = ANY(select actor_id From movie_actor where movie_id IN (101, 110, 121));

-- select all movies whose rating is greater than *any* of the marvel movies rating
	select * from movies where imdb_rating > ANY(select imdb_rating from movies where studio="Marvel studios");

-- Above, can be achieved in another way too (sub query, min)
	select * from movies where imdb_rating > (select min(imdb_rating) from movies where studio="Marvel studios");

-- select all movies whose rating is greater than *all* of the marvel movies rating
	select * from movies where imdb_rating > ALL(select imdb_rating from movies where studio="Marvel studios");

-- Above, can be achieved in another way too (sub query, max)
	select * from movies where imdb_rating > (select max(imdb_rating) from movies where studio="Marvel studios");





### Module: Co-Related Subquery

-- Get the actor id, actor name and the total number of movies they acted in.
	SELECT 
           actor_id, 
           name, 
	   (SELECT COUNT(*) FROM movie_actor WHERE actor_id = actors.actor_id) as movies_count
	FROM actors
	ORDER BY movies_count DESC;

-- Above, can be achieved by using Joins too!
	select 
	    a.actor_id, 
	    a.name, 
	    count(*) as movie_count
	from movie_actor ma
	join actors a
	on a.actor_id=ma.actor_id
	group by actor_id
	order by movie_count desc;




### Module: Common Table Expression (CTE)

-- Select all the actors whose age is greater than 70 and less than 85 [Previously, we have used sub-queries to solve this. Now we use CTE's]
	with actors_age as 
	   (select
                name as actor_name,
                year(curdate()) - birth_year as age
            from actors
	    )
	select actor_name, age from actors_age where age > 70 and age < 85;


-- Movies that produced 500% profit and their rating was less than average rating for all movies
	with 
	   x as 
	      (select 
		   *, 
                   (revenue-budget)*100/budget as pct_profit
               from financials),
    	   y as 
	      (select * from movies where imdb_rating < (select avg(imdb_rating) from movies))
	select 
	    x.movie_id, y.title, x.pct_profit, y.imdb_rating
	from x
	join y
	on x.movie_id=y.movie_id
	where x.pct_profit > 500;


-- Above, can be achieved using sub-query too (But, code readability is less here compared to CTE's)
	select 
	   x.movie_id, y.title, x.pct_profit, y.imdb_rating
	from ( 
              select
                  *, 
                  (revenue-budget)*100/budget as pct_profit
              from financials
	     ) x
	join 
	     (select * from movies where imdb_rating < (select avg(imdb_rating) from movies)) y
	on x.movie_id=y.movie_id
	where pct_profit>500;




TOPIC 2

Chapter:- SQL Basics: Database Creation & Updates




### Module: Insert Statement

-- Simple insert for new record in movies
	INSERT INTO movies VALUES (141, "Bahuhbali 3", "Bollywood", 2030, 9.0, "Arka Media Works", 2);

-- Insert with NULL or DEFAULT values
	INSERT INTO movies VALUES (142, "Thor 10", "Hollywood", NULL, DEFAULT, "Marvel Studios", 5);

-- Same insert with column names
	INSERT INTO movies (movie_id, title, industry, language_id) VALUES (143, "Pushpa 5", "Bollywood", 2);

-- Insert with invalid language_id. Foreign key constraint fails
	INSERT INTO movies (movie_id, title, industry, language_id) VALUES (144, "Pushpa 6", "Bollywood", 10);

-- Insert multiple rows
	INSERT INTO movies 
    	     (movie_id, title, industry, language_id)
	VALUES 
    	     (145, "Inception 2", "Hollywood", 5),
             (146, "Inception 3", "Hollywood", 5),
             (147, "Inception 4", "Hollywood", 5);



### Module: Update and Delete

-- Say THOR 10 movie is released in 2050, and you want to update the rating now :)
	UPDATE movies 
	SET imdb_rating=8, release_year=2050
	WHERE movie_id=142;

-- Update multiple records. [Update all studios with 'Warner Bros. Pictures' for all the Inception movies records] 
	UPDATE movies 
	SET studio='Warner Bros. Pictures'
	WHERE title like "Inception %";

-- Delete all new inception movies
	DELETE FROM movies 
	WHERE  title like "Inception %";

-- Another delete to restore the database to normal again
	DELETE FROM movies 
	WHERE movie_id in (141, 142, 143);












QUESTIOS/MOCK-UP OF all PROJECT :-

1)FINANCE ANALYTICS :- Croma India Product wise sales report for Fiscal year 2021 
 
The report should have a following field :

Month, Product Name, Variant, Sold Quantity, Gross Price Per item, Gross Price Total

2)SALES ANALYTICS :- Gross monthly total sales report for Croma

Month, Total Monthly Gross Sales Amount for Croma in India

3)SALES ANALYTICS :-

3.1) Report For TOP Markets :- Rank, Market, Net sales

3.2) Report For TOP Products :- Rank, Products, Net sales

3.3) Report For TOP Customers :- Rank, Customers, Net sales (WINDOW FUNCTION)


4) Forecast Accuracy for all Customers for a Given Fiscal year




1) USER DEFINED FUNCTION 

1.1) get_fiscal_year
1.2) get_fiscal_Quater


2) Stored Procedure 

2.1) get_montly_market_gross_sales_for_customer

2.2) get_market_Badge

Input :- Market, Fiscal year
Output :- Market Badge

2.3) Net_invoice_sales

2.4) get_top_N_marketes_by_net_sales

2.5) get_top_N_customer_by_net_sales

2.6) get_top_N_products_per_division_by_qty_sold

2.7) get_forecast_accuracy


3) Database Views

3.1) sales_preinvoice_discount

3.2) sales_post_invoice_discount

3.3) net_sales











Chapter:- SQL Advanced: Finance Analytics



### Module: User-Defined SQL Functions

-- a. first grab customer codes for Croma india
	SELECT * FROM dim_customer WHERE customer like "%croma%" AND market="india";

-- b. Get all the sales transaction data from fact_sales_monthly table for that customer(croma: 90002002) in the fiscal_year 2021
	SELECT * FROM fact_sales_monthly 
	WHERE 
            customer_code=90002002 AND
            YEAR(DATE_ADD(date, INTERVAL 4 MONTH))=2021 
	ORDER BY date asc
	LIMIT 100000;

-- c. create a function 'get_fiscal_year' to get fiscal year by passing the date
	CREATE FUNCTION `get_fiscal_year`(calendar_date DATE) 
	RETURNS int
    	DETERMINISTIC
	BEGIN
        	DECLARE fiscal_year INT;
        	SET fiscal_year = YEAR(DATE_ADD(calendar_date, INTERVAL 4 MONTH));
        	RETURN fiscal_year;
	END

-- d. Replacing the function created in the step:b
	SELECT * FROM fact_sales_monthly 
	WHERE 
            customer_code=90002002 AND
            get_fiscal_year(date)=2021 
	ORDER BY date asc
	LIMIT 100000;



### Module: Gross Sales Report: Monthly Product Transactions

-- a. Perform joins to pull product information
	SELECT s.date, s.product_code, p.product, p.variant, s.sold_quantity 
	FROM fact_sales_monthly s
	JOIN dim_product p
        ON s.product_code=p.product_code
	WHERE 
            customer_code=90002002 AND 
    	    get_fiscal_year(date)=2021     
	LIMIT 1000000;

-- b. Performing join with 'fact_gross_price' table with the above query and generating required fields
	SELECT 
    	    s.date, 
            s.product_code, 
            p.product, 
            p.variant, 
            s.sold_quantity, 
            g.gross_price,
            ROUND(s.sold_quantity*g.gross_price,2) as gross_price_total
	FROM fact_sales_monthly s
	JOIN dim_product p
            ON s.product_code=p.product_code
	JOIN fact_gross_price g
            ON g.fiscal_year=get_fiscal_year(s.date)
    	AND g.product_code=s.product_code
	WHERE 
    	    customer_code=90002002 AND 
            get_fiscal_year(s.date)=2021     
	LIMIT 1000000;




### Module: Gross Sales Report: Total Sales Amount

-- Generate monthly gross sales report for Croma India for all the years
	SELECT 
            s.date, 
    	    SUM(ROUND(s.sold_quantity*g.gross_price,2)) as monthly_sales
	FROM fact_sales_monthly s
	JOIN fact_gross_price g
        ON g.fiscal_year=get_fiscal_year(s.date) AND g.product_code=s.product_code
	WHERE 
             customer_code=90002002
	GROUP BY date;



### Module: Stored Procedures: Monthly Gross Sales Report

-- Generate monthly gross sales report for any customer using stored procedure
	CREATE PROCEDURE `get_monthly_gross_sales_for_customer`(
        	in_customer_codes TEXT
	)
	BEGIN
        	SELECT 
                    s.date, 
                    SUM(ROUND(s.sold_quantity*g.gross_price,2)) as monthly_sales
        	FROM fact_sales_monthly s
        	JOIN fact_gross_price g
               	    ON g.fiscal_year=get_fiscal_year(s.date)
                    AND g.product_code=s.product_code
        	WHERE 
                    FIND_IN_SET(s.customer_code, in_customer_codes) > 0
        	GROUP BY s.date
        	ORDER BY s.date DESC;
	END




### Module: Stored Procedure: Market Badge

--  Write a stored proc that can retrieve market badge. i.e. if total sold quantity > 5 million that market is considered "Gold" else "Silver"
	CREATE PROCEDURE 'get_market_badge'(
        	IN in_market VARCHAR(45),
        	IN in_fiscal_year YEAR,
        	OUT out_level VARCHAR(45)
	)
	BEGIN
             DECLARE qty INT DEFAULT 0;
    
    	     # Default market is India
    	     IF in_market = "" THEN
                  SET in_market="India";
             END IF;
    
    	     # Retrieve total sold quantity for a given market in a given year
             SELECT 
                  SUM(s.sold_quantity) INTO qty
             FROM fact_sales_monthly s
             JOIN dim_customer c
             ON s.customer_code=c.customer_code
             WHERE 
                  get_fiscal_year(s.date)=in_fiscal_year AND
                  c.market=in_market;
        
             # Determine Gold vs Silver status
             IF qty > 5000000 THEN
                  SET out_level = 'Gold';
             ELSE
                  SET out_level = 'Silver';
             END IF;
	END







Chapter:- SQL Advanced: Top Customers, Products, Markets



### Module: Problem Statement and Pre-Invoice Discount Report

-- Include pre-invoice deductions in Croma detailed report
	SELECT 
    	   s.date, 
           s.product_code, 
           p.product, 
	   p.variant, 
           s.sold_quantity, 
           g.gross_price as gross_price_per_item,
           ROUND(s.sold_quantity*g.gross_price,2) as gross_price_total,
           pre.pre_invoice_discount_pct
	FROM fact_sales_monthly s
	JOIN dim_product p
            ON s.product_code=p.product_code
	JOIN fact_gross_price g
    	    ON g.fiscal_year=get_fiscal_year(s.date)
    	    AND g.product_code=s.product_code
	JOIN fact_pre_invoice_deductions as pre
            ON pre.customer_code = s.customer_code AND
            pre.fiscal_year=get_fiscal_year(s.date)
	WHERE 
	    s.customer_code=90002002 AND 
    	    get_fiscal_year(s.date)=2021     
	LIMIT 1000000;get

-- Same report but all the customers
	SELECT 
    	   s.date, 
           s.product_code, 
           p.product, 
	   p.variant, 
           s.sold_quantity, 
           g.gross_price as gross_price_per_item,
           ROUND(s.sold_quantity*g.gross_price,2) as gross_price_total,
           pre.pre_invoice_discount_pct
	FROM fact_sales_monthly s
	JOIN dim_product p
            ON s.product_code=p.product_code
	JOIN fact_gross_price g
    	    ON g.fiscal_year=get_fiscal_year(s.date)
    	    AND g.product_code=s.product_code
	JOIN fact_pre_invoice_deductions as pre
            ON pre.customer_code = s.customer_code AND
            pre.fiscal_year=get_fiscal_year(s.date)
	WHERE 
    	    get_fiscal_year(s.date)=2021     
	LIMIT 1000000;





### Module: Performance Improvement # 1

-- creating dim_date and joining with this table and avoid using the function 'get_fiscal_year()' to reduce the amount of time taking to run the query
	SELECT 
    	    s.date, 
            s.customer_code,
            s.product_code, 
            p.product, p.variant, 
            s.sold_quantity, 
            g.gross_price as gross_price_per_item,
            ROUND(s.sold_quantity*g.gross_price,2) as gross_price_total,
            pre.pre_invoice_discount_pct
	FROM fact_sales_monthly s
	JOIN dim_date dt
        	ON dt.calendar_date = s.date
	JOIN dim_product p
        	ON s.product_code=p.product_code
	JOIN fact_gross_price g
    		ON g.fiscal_year=dt.fiscal_year
    		AND g.product_code=s.product_code
	JOIN fact_pre_invoice_deductions as pre
        	ON pre.customer_code = s.customer_code AND
    		pre.fiscal_year=dt.fiscal_year
	WHERE 
    		dt.fiscal_year=2021     
	LIMIT 1500000;







### Module: Performance Improvement # 2

-- Added the fiscal year in the fact_sales_monthly table itself
	SELECT 
    	    s.date, 
            s.customer_code,
            s.product_code, 
            p.product, p.variant, 
            s.sold_quantity, 
            g.gross_price as gross_price_per_item,
            ROUND(s.sold_quantity*g.gross_price,2) as gross_price_total,
            pre.pre_invoice_discount_pct
	FROM fact_sales_monthly s
	JOIN dim_product p
        	ON s.product_code=p.product_code
	JOIN fact_gross_price g
    		ON g.fiscal_year=s.fiscal_year
    		AND g.product_code=s.product_code
	JOIN fact_pre_invoice_deductions as pre
        	ON pre.customer_code = s.customer_code AND
    		pre.fiscal_year=s.fiscal_year
	WHERE 
    		s.fiscal_year=2021     
	LIMIT 1500000;





### Module: Database Views: Introduction

-- Get the net_invoice_sales amount using the CTE's
	WITH cte1 AS (
		SELECT 
    		    s.date, 
    		    s.customer_code,
    		    s.product_code, 
                    p.product, p.variant, 
                    s.sold_quantity, 
                    g.gross_price as gross_price_per_item,
                    ROUND(s.sold_quantity*g.gross_price,2) as gross_price_total,
                    pre.pre_invoice_discount_pct
		FROM fact_sales_monthly s
		JOIN dim_product p
        		ON s.product_code=p.product_code
		JOIN fact_gross_price g
    			ON g.fiscal_year=s.fiscal_year
    			AND g.product_code=s.product_code
		JOIN fact_pre_invoice_deductions as pre
        		ON pre.customer_code = s.customer_code AND
    			pre.fiscal_year=s.fiscal_year
		WHERE 
    			s.fiscal_year=2021) 
	SELECT 
      	    *, 
    	    (gross_price_total-pre_invoice_discount_pct*gross_price_total) as net_invoice_sales
	FROM cte1
	LIMIT 1500000;


-- Creating the view `sales_preinv_discount` and store all the data in like a virtual table
	CREATE  VIEW `sales_preinv_discount` AS
	SELECT 
    	    s.date, 
            s.fiscal_year,
            s.customer_code,
            c.market,
            s.product_code, 
            p.product, 
            p.variant, 
            s.sold_quantity, 
            g.gross_price as gross_price_per_item,
            ROUND(s.sold_quantity*g.gross_price,2) as gross_price_total,
            pre.pre_invoice_discount_pct
	FROM fact_sales_monthly s
	JOIN dim_customer c 
		ON s.customer_code = c.customer_code
	JOIN dim_product p
        	ON s.product_code=p.product_code
	JOIN fact_gross_price g
    		ON g.fiscal_year=s.fiscal_year
    		AND g.product_code=s.product_code
	JOIN fact_pre_invoice_deductions as pre
        	ON pre.customer_code = s.customer_code AND
    		pre.fiscal_year=s.fiscal_year

-- Now generate net_invoice_sales using the above created view "sales_preinv_discount"
	SELECT 
            *,
    	    (gross_price_total-pre_invoice_discount_pct*gross_price_total) as net_invoice_sales
	FROM gdb0041.sales_preinv_discount







### Module: Database Views: Post Invoice Discount, Net Sales

-- Create a view for post invoice deductions: `sales_postinv_discount`
	CREATE VIEW `sales_postinv_discount` AS
	SELECT 
    	    s.date, s.fiscal_year,
            s.customer_code, s.market,
            s.product_code, s.product, s.variant,
            s.sold_quantity, s.gross_price_total,
            s.pre_invoice_discount_pct,
            (s.gross_price_total-s.pre_invoice_discount_pct*s.gross_price_total) as net_invoice_sales,
            (po.discounts_pct+po.other_deductions_pct) as post_invoice_discount_pct
	FROM sales_preinv_discount s
	JOIN fact_post_invoice_deductions po
		ON po.customer_code = s.customer_code AND
   		po.product_code = s.product_code AND
   		po.date = s.date;

-- Create a report for net sales
	SELECT 
            *, 
    	    net_invoice_sales*(1-post_invoice_discount_pct) as net_sales
	FROM gdb0041.sales_postinv_discount;

-- Finally creating the view `net_sales` which inbuiltly use/include all the previous created view and gives the final result
	CREATE VIEW `net_sales` AS
	SELECT 
            *, 
    	    net_invoice_sales*(1-post_invoice_discount_pct) as net_sales
	FROM gdb0041.sales_postinv_discount;






### Module: Top Markets and Customers 

-- Get top 5 market by net sales in fiscal year 2021
	SELECT 
    	    market, 
            round(sum(net_sales)/1000000,2) as net_sales_mln
	FROM gdb0041.net_sales
	where fiscal_year=2021
	group by market
	order by net_sales_mln desc
	limit 5

-- Stored proc to get top n markets by net sales for a given year
	CREATE PROCEDURE `get_top_n_markets_by_net_sales`(
        	in_fiscal_year INT,
    		in_top_n INT
	)
	BEGIN
        	SELECT 
                     market, 
                     round(sum(net_sales)/1000000,2) as net_sales_mln
        	FROM net_sales
        	where fiscal_year=in_fiscal_year
        	group by market
        	order by net_sales_mln desc
        	limit in_top_n;
	END

-- stored procedure that takes market, fiscal_year and top n as an input and returns top n customers by net sales in that given fiscal year and market
	CREATE PROCEDURE `get_top_n_customers_by_net_sales`(
        	in_market VARCHAR(45),
        	in_fiscal_year INT,
    		in_top_n INT
	)
	BEGIN
        	select 
                     customer, 
                     round(sum(net_sales)/1000000,2) as net_sales_mln
        	from net_sales s
        	join dim_customer c
                on s.customer_code=c.customer_code
        	where 
		    s.fiscal_year=in_fiscal_year 
		    and s.market=in_market
        	group by customer
        	order by net_sales_mln desc
        	limit in_top_n;
	END




   
### Module: Window Functions: OVER Clause

-- show % of total expense
	select 
             *,
    	     amount*100/sum(amount) over() as pct
	from random_tables.expenses 
	order by category;

-- show % of total expense per category
	select 
            *,
    	    amount*100/sum(amount) over(partition by category) as pct
	from random_tables.expenses 
	order by category,  pct desc;

-- Show expenses per category till date
	select 
             *,
             sum(amount) over(partition by category order by date) as expenses_till_date
	from random_tables.expenses;







### Module: Window Functions: Using it In a Task

-- find out customer wise net sales percentage contribution 
	with cte1 as (
		select 
                    customer, 
                    round(sum(net_sales)/1000000,2) as net_sales_mln
        	from net_sales s
        	join dim_customer c
                    on s.customer_code=c.customer_code
        	where s.fiscal_year=2021
        	group by customer)
	select 
            *,
            net_sales_mln*100/sum(net_sales_mln) over() as pct_net_sales
	from cte1
	order by net_sales_mln desc





### Module: Exercise: Window Functions: OVER Clause

-- Find customer wise net sales distibution per region for FY 2021
	with cte1 as (
		select 
        	    c.customer,
                    c.region,
                    round(sum(net_sales)/1000000,2) as net_sales_mln
                from gdb0041.net_sales n
                join dim_customer c
                    on n.customer_code=c.customer_code
		where fiscal_year=2021
		group by c.customer, c.region)
	select
             *,
             net_sales_mln*100/sum(net_sales_mln) over (partition by region) as pct_share_region
	from cte1
	order by region, pct_share_region desc




### Module: Window Functions: ROW_NUMBER, RANK, DENSE_RANK

-- Show top 2 expenses in each category
	select * from 
	     (select 
                  *, 
    	          row_number() over (partition by category order by amount desc) as row_num
	      from random_tables.expenses) x
	where x.row_num<3

--  If two items have same expense then row_number doesnt work. We need a true rank for which we need to use either a rank or dense_rank() function.(demo using student_marks table)
	select 
	     *,
             row_number() over (order by marks desc) as row_num,
             rank() over (order by marks desc) as rank_num,
             dense_rank() over (order by marks desc) as dense_rank_num
	from random_tables.student_marks;

-- Find out top 3 products from each division by total quantity sold in a given year
	with cte1 as 
		(select
                     p.division,
                     p.product,
                     sum(sold_quantity) as total_qty
                from fact_sales_monthly s
                join dim_product p
                      on p.product_code=s.product_code
                where fiscal_year=2021
                group by p.product),
           cte2 as 
	        (select 
                     *,
                     dense_rank() over (partition by division order by total_qty desc) as drnk
                from cte1)
	select * from cte2 where drnk<=3

-- Creating stored procedure for the above query
	CREATE PROCEDURE `get_top_n_products_per_division_by_qty_sold`(
        	in_fiscal_year INT,
    		in_top_n INT
	)
	BEGIN
	     with cte1 as (
		   select
                       p.division,
                       p.product,
                       sum(sold_quantity) as total_qty
                   from fact_sales_monthly s
                   join dim_product p
                       on p.product_code=s.product_code
                   where fiscal_year=in_fiscal_year
                   group by p.product),            
             cte2 as (
		   select 
                        *,
                        dense_rank() over (partition by division order by total_qty desc) as drnk
                   from cte1)
	     select * from cte2 where drnk <= in_top_n;
	END
















Chapter:- SQL Advanced: Supply Chain Analytics



### Module: Create a Helper Table

-- Create fact_act_est table
	drop table if exists fact_act_est;

	create table fact_act_est
	(
        	select 
                    s.date as date,
                    s.fiscal_year as fiscal_year,
                    s.product_code as product_code,
                    s.customer_code as customer_code,
                    s.sold_quantity as sold_quantity,
                    f.forecast_quantity as forecast_quantity
        	from 
                    fact_sales_monthly s
        	left join fact_forecast_monthly f 
        	using (date, customer_code, product_code)
	)
	union
	(
        	select 
                    f.date as date,
                    f.fiscal_year as fiscal_year,
                    f.product_code as product_code,
                    f.customer_code as customer_code,
                    s.sold_quantity as sold_quantity,
                    f.forecast_quantity as forecast_quantity
        	from 
		    fact_forecast_monthly  f
        	left join fact_sales_monthly s 
        	using (date, customer_code, product_code)
	);

	update fact_act_est
	set sold_quantity = 0
	where sold_quantity is null;

	update fact_act_est
	set forecast_quantity = 0
	where forecast_quantity is null;





### Module: Database Triggers

-- create the trigger to automatically insert record in fact_act_est table whenever insertion happens in fact_sales_monthly 
	CREATE DEFINER=CURRENT_USER TRIGGER `fact_sales_monthly_AFTER_INSERT` AFTER INSERT ON `fact_sales_monthly` FOR EACH ROW 
	BEGIN
        	insert into fact_act_est 
                        (date, product_code, customer_code, sold_quantity)
    		values (
                	NEW.date, 
        		NEW.product_code, 
        		NEW.customer_code, 
        		NEW.sold_quantity
    		 )
    		on duplicate key update
                         sold_quantity = values(sold_quantity);
	END

-- create the trigger to automatically insert record in fact_act_est table whenever insertion happens in fact_forecast_monthly 
	CREATE DEFINER=CURRENT_USER TRIGGER `fact_forecast_monthly_AFTER_INSERT` AFTER INSERT ON `fact_forecast_monthly` FOR EACH ROW 
	BEGIN
        	insert into fact_act_est 
                        (date, product_code, customer_code, forecast_quantity)
    		values (
                	NEW.date, 
        		NEW.product_code, 
        		NEW.customer_code, 
        		NEW.forecast_quantity
    		 )
    		on duplicate key update
                         forecast_quantity = values(forecast_quantity);
	END

-- To see all the Triggers
        show triggers;

-- Insert the records in the fact_sales_monthly and fact_forecast_monthly tables and check whether records inserted in fact_act_est table
	insert into fact_sales_monthly
              (date, product_code, customer_code, sold_quantity)
	values 
	      ("2030-09-01", "HAHA", 99, 89);

	insert into fact_forecast_monthly
             (date, product_code, customer_code, forecast_quantity)
	values 
	      ("2030-09-01", "HAHA", 99, 43);

	select * from fact_act_est where customer_code = 99;







### Module: Database Events

-- To show all the events
	show events;

-- Show variable which have event in it
	show variables like "%event%";

-- Creating the table "session_logs" in the random table and also insert the records in it
	CREATE TABLE random_tables.session_logs (`ts` DATETIME, `session_id` INT, `user_id` INT, `log` TEXT);
	INSERT INTO `random_tables`.`session_logs` 
                (`ts`, `session_id`, `user_id`, `log`) 
	VALUES 
            	('2022-10-04 08:14:07', '898812', '523', 'CLICKED | Courses Buttom'),
        	('2022-10-14 08:18:35', '898812', '523', 'NAVIAGE BACK | Python course page , codebasics.io'),
        	('2022-10-16 12:07:00', '965345', '523', 'REVIEW GENERATED | Data analytics in power bi'),
        	('2022-10-22 14:09:22', '188567', '707', 'NEW LOGIN | New login, user name: tasty@jalebi.com'),
        	('2022-10-22 18:10:06', '188567', '707', 'COURSE PURCHASED | Data analytics in power bi, user name: tasty@jalebi.com');

-- Delete logs that are less than 5 days old
	delimiter |
	CREATE EVENT e_daily_log_purge
    	ON SCHEDULE
      	EVERY 5 SECOND
    	COMMENT 'Purge logs that are more than 5 days old'
    	DO
      	     BEGIN
        	delete from random_tables.session_logs 
        	where DATE(ts) < DATE("2022-10-22") - interval 5 day;
      	     END |
        delimiter ;

-- drop the event
       drop event if exists e_daily_log_purge;






### Module: Temporary Tables & Forecast Accuracy Report

-- Forecast accuracy report using cte (It exists at the scope of statements)
	with forecast_err_table as (
             select
                  s.customer_code as customer_code,
                  c.customer as customer_name,
                  c.market as market,
                  sum(s.sold_quantity) as total_sold_qty,
                  sum(s.forecast_quantity) as total_forecast_qty,
                  sum(s.forecast_quantity-s.sold_quantity) as net_error,
                  round(sum(s.forecast_quantity-s.sold_quantity)*100/sum(s.forecast_quantity),1) as net_error_pct,
                  sum(abs(s.forecast_quantity-s.sold_quantity)) as abs_error,
                  round(sum(abs(s.forecast_quantity-sold_quantity))*100/sum(s.forecast_quantity),2) as abs_error_pct
             from fact_act_est s
             join dim_customer c
             on s.customer_code = c.customer_code
             where s.fiscal_year=2021
             group by customer_code
	)
	select 
            *,
            if (abs_error_pct > 100, 0, 100.0 - abs_error_pct) as forecast_accuracy
	from forecast_err_table
        order by forecast_accuracy desc;

-- Write a stored proc for the same
	CREATE PROCEDURE `get_forecast_accuracy`(
        	in_fiscal_year INT
	)
	BEGIN
		with forecast_err_table as (
             	       select
                           s.customer_code as customer_code,
                           c.customer as customer_name,
                           c.market as market,
                           sum(s.sold_quantity) as total_sold_qty,
                           sum(s.forecast_quantity) as total_forecast_qty,
                           sum(s.forecast_quantity-s.sold_quantity) as net_error,
                           round(sum(s.forecast_quantity-s.sold_quantity)*100/sum(s.forecast_quantity),1) as net_error_pct,
                           sum(abs(s.forecast_quantity-s.sold_quantity)) as abs_error,
                           round(sum(abs(s.forecast_quantity-sold_quantity))*100/sum(s.forecast_quantity),2) as abs_error_pct
             	       from fact_act_est s
             	       join dim_customer c
                       on s.customer_code = c.customer_code
                       where s.fiscal_year=in_fiscal_year
                       group by customer_code
	        )
	        select 
                    *,
                    if (abs_error_pct > 100, 0, 100.0 - abs_error_pct) as forecast_accuracy
	        from forecast_err_table
                order by forecast_accuracy desc;
	END

-- Forecast accuracy report using temporary table (It exists for the entire session)
	drop table if exists forecast_err_table;
	create temporary table forecast_err_table
             select
                  s.customer_code as customer_code,
                  c.customer as customer_name,
                  c.market as market,
                  sum(s.sold_quantity) as total_sold_qty,
                  sum(s.forecast_quantity) as total_forecast_qty,
                  sum(s.forecast_quantity-s.sold_quantity) as net_error,
                  round(sum(s.forecast_quantity-s.sold_quantity)*100/sum(s.forecast_quantity),1) as net_error_pct,
                  sum(abs(s.forecast_quantity-s.sold_quantity)) as abs_error,
                  round(sum(abs(s.forecast_quantity-sold_quantity))*100/sum(s.forecast_quantity),2) as abs_error_pct
             from fact_act_est s
             join dim_customer c
             on s.customer_code = c.customer_code
             where s.fiscal_year=2021
             group by customer_code;

	select 
            *,
            if (abs_error_pct > 100, 0, 100.0 - abs_error_pct) as forecast_accuracy
	from forecast_err_table
        order by forecast_accuracy desc;
	
	
	

### Module: User Accounts and Privileges

-- Show all grants available for a particular user(wanda)
	show grants for 'wanda';

-- Create a new user 'thor' 
	create user 'thor'@'localhost' identified by 'thor';

-- Allow certain access to 'thor' user for the database 'gdb041'
     	grant select on gdb041.dim_customer to 'thor'@'localhost';
     	grant select on gdb041.dim_product to 'thor'@'localhost';
     	grant execute on procedure gdb041.get_forecast_accuracy_report to 'thor'@'localhost';

-- See all the access for 'thor' user
	show grants for 'thor'@'localhost';




### Module: Database Indexes: Index Types (make sakila database as default one)
	
-- Query1
	select * from film where description like "%car%" or "%boat%";

-- Query2
	select * from sakila.film 
	where match(description) against("car boat")
	limit 1000

-- Query3
	select * from sakila.film 
	where match(description) against("car -boat" in boolean mode)
	limit 1000

















 

